[{"id":0,"href":"/de/docs/swt/implementations/examples/go/client-side-token-generation/","title":"Client-seitige Token-Generierung","section":"Go","content":" Client-seitige Token-Generierung # TBD!\n"},{"id":1,"href":"/de/docs/swt/implementations/examples/js/client-side-token-generation/","title":"Client-seitige Token-Generierung","section":"JavaScript","content":" Client-seitige Token-Generierung # // Für HEAD-Requests (kleine Payloads) function sendWebhookHEAD(endpoint, webhookData, secret) { const token = createSWT(webhookData, null, secret); return fetch(endpoint, { method: \u0026#39;HEAD\u0026#39;, headers: { \u0026#39;Authorization\u0026#39;: `Bearer ${token}`, \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39; } }); } // Für POST-Requests (größere Payloads) function sendWebhookPOST(endpoint, webhookData, payload, secret) { const token = createSWT(webhookData, payload, secret); return fetch(endpoint, { method: \u0026#39;POST\u0026#39;, headers: { \u0026#39;Authorization\u0026#39;: `Bearer ${token}`, \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39; }, body: JSON.stringify(payload) }); } "},{"id":2,"href":"/de/docs/swt/implementations/examples/python/create-validate-secure-webhook-token/","title":"Create \u0026 Validate Secure Webhook Token","section":"Python","content":" Create \u0026amp; Validate Secure Webhook Token # import jwt import hashlib import json import time import uuid from datetime import datetime, timedelta def create_swt(webhook_data, payload=None, secret=None): now = int(time.time()) claims = { \u0026#39;webhook\u0026#39;: { \u0026#39;event\u0026#39;: webhook_data[\u0026#39;event\u0026#39;], \u0026#39;data\u0026#39;: webhook_data.get(\u0026#39;data\u0026#39;, {}) }, \u0026#39;iss\u0026#39;: \u0026#39;webhook-service.example.com\u0026#39;, \u0026#39;exp\u0026#39;: now + 300, # 5 Minuten gültig \u0026#39;nbf\u0026#39;: now, \u0026#39;iat\u0026#39;: now, \u0026#39;jti\u0026#39;: str(uuid.uuid4()) } # Payload-Hash hinzufügen falls vorhanden if payload: payload_str = json.dumps(payload, separators=(\u0026#39;,\u0026#39;, \u0026#39;:\u0026#39;), sort_keys=True) hash_obj = hashlib.sha256(payload_str.encode(\u0026#39;utf-8\u0026#39;)) claims[\u0026#39;webhook\u0026#39;][\u0026#39;hash\u0026#39;] = f\u0026#34;sha256:{hash_obj.hexdigest()}\u0026#34; return jwt.encode(claims, secret, algorithm=\u0026#39;HS256\u0026#39;) def validate_swt(token, payload=None, secret=None): try: decoded = jwt.decode(token, secret, algorithms=[\u0026#39;HS256\u0026#39;]) # Pflicht-Claims prüfen required_claims = [\u0026#39;webhook\u0026#39;, \u0026#39;iss\u0026#39;, \u0026#39;exp\u0026#39;, \u0026#39;nbf\u0026#39;, \u0026#39;iat\u0026#39;, \u0026#39;jti\u0026#39;] for claim in required_claims: if claim not in decoded: raise ValueError(f\u0026#39;Fehlender Pflicht-Claim: {claim}\u0026#39;) # Payload-Hash validieren falls vorhanden if payload and \u0026#39;hash\u0026#39; in decoded[\u0026#39;webhook\u0026#39;]: algorithm, expected_hash = decoded[\u0026#39;webhook\u0026#39;][\u0026#39;hash\u0026#39;].split(\u0026#39;:\u0026#39;) payload_str = json.dumps(payload, separators=(\u0026#39;,\u0026#39;, \u0026#39;:\u0026#39;), sort_keys=True) if algorithm == \u0026#39;sha256\u0026#39;: actual_hash = hashlib.sha256(payload_str.encode(\u0026#39;utf-8\u0026#39;)).hexdigest() else: raise ValueError(f\u0026#39;Ununterstützter Hash-Algorithmus: {algorithm}\u0026#39;) if actual_hash != expected_hash: raise ValueError(\u0026#39;Payload-Hash stimmt nicht überein\u0026#39;) return decoded except jwt.InvalidTokenError as e: raise ValueError(f\u0026#39;SWT-Validierung fehlgeschlagen: {str(e)}\u0026#39;) "},{"id":3,"href":"/de/docs/swt/implementations/examples/js/replay-protection/","title":"Replay-Schutz mit Redis","section":"JavaScript","content":" Replay-Schutz mit Redis # const redis = require(\u0026#39;redis\u0026#39;); const client = redis.createClient(); class RedisReplayProtection { constructor(redisClient) { this.redis = redisClient; } async checkAndAddToken(jti, expiration) { const exists = await this.redis.exists(`swt:${jti}`); if (exists) { throw new Error(\u0026#39;Token bereits verwendet (Replay-Angriff)\u0026#39;); } const ttl = expiration - Math.floor(Date.now() / 1000); if (ttl \u0026gt; 0) { await this.redis.setex(`swt:${jti}`, ttl, \u0026#39;1\u0026#39;); } } } // Verwendung const replayProtection = new RedisReplayProtection(client); async function validateSWTWithReplayProtection(token, payload, secret) { const decoded = validateSWT(token, payload, secret); await replayProtection.checkAndAddToken(decoded.jti, decoded.exp); return decoded; } "},{"id":4,"href":"/de/docs/swt/implementations/examples/js/server-side-validation/","title":"Server-seitige Validierung","section":"JavaScript","content":" Server-seitige Validierung (Node.js) # Vollständige SWT-Validierung # const jwt = require(\u0026#39;jsonwebtoken\u0026#39;); const crypto = require(\u0026#39;crypto\u0026#39;); function validateSWT(token, payload, secret) { try { // JWT dekodieren und validieren const decoded = jwt.verify(token, secret); // Pflicht-Claims prüfen if (!decoded.webhook || !decoded.iss || !decoded.exp || !decoded.nbf || !decoded.iat || !decoded.jti) { throw new Error(\u0026#39;Fehlende Pflicht-Claims\u0026#39;); } // Zeitvalidierung const now = Math.floor(Date.now() / 1000); if (decoded.exp \u0026lt;= now || decoded.nbf \u0026gt; now) { throw new Error(\u0026#39;Token abgelaufen oder noch nicht gültig\u0026#39;); } // Payload-Hash validieren (falls vorhanden) if (payload \u0026amp;\u0026amp; decoded.webhook.hash) { const [algorithm, expectedHash] = decoded.webhook.hash.split(\u0026#39;:\u0026#39;); const actualHash = crypto.createHash(algorithm) .update(JSON.stringify(payload)) .digest(\u0026#39;hex\u0026#39;); if (actualHash !== expectedHash) { throw new Error(\u0026#39;Payload-Hash stimmt nicht überein\u0026#39;); } } return decoded; } catch (error) { throw new Error(`SWT-Validierung fehlgeschlagen: ${error.message}`); } } Token-Erstellung # const jwt = require(\u0026#39;jsonwebtoken\u0026#39;); const crypto = require(\u0026#39;crypto\u0026#39;); function createSWT(webhookData, payload, secret) { const now = Math.floor(Date.now() / 1000); const claims = { webhook: { event: webhookData.event, data: webhookData.data }, iss: \u0026#39;webhook-service.example.com\u0026#39;, exp: now + 300, // 5 Minuten gültig nbf: now, iat: now, jti: crypto.randomUUID() }; // Payload-Hash hinzufügen (falls vorhanden) if (payload) { const hash = crypto.createHash(\u0026#39;sha256\u0026#39;) .update(JSON.stringify(payload)) .digest(\u0026#39;hex\u0026#39;); claims.webhook.hash = `sha256:${hash}`; } return jwt.sign(claims, secret, { algorithm: \u0026#39;HS256\u0026#39; }); } "},{"id":5,"href":"/de/docs/swt/implementations/examples/js/webhook-handler/","title":"Webhook-Handler","section":"JavaScript","content":" Webhook-Handler (Express.js) # const express = require(\u0026#39;express\u0026#39;); const app = express(); app.use(express.json()); app.post(\u0026#39;/webhook\u0026#39;, (req, res) =\u0026gt; { try { const token = req.headers.authorization?.replace(\u0026#39;Bearer \u0026#39;, \u0026#39;\u0026#39;); if (!token) { return res.status(401).json({ error: \u0026#39;Authorization header fehlt\u0026#39; }); } const validatedToken = validateSWT(token, req.body, process.env.WEBHOOK_SECRET); // Webhook verarbeiten processWebhook(validatedToken.webhook, req.body); res.status(200).json({ status: \u0026#39;success\u0026#39; }); } catch (error) { console.error(\u0026#39;Webhook-Validierung fehlgeschlagen:\u0026#39;, error.message); res.status(401).json({ error: \u0026#39;Unauthorized\u0026#39;, message: error.message }); } }); function processWebhook(webhookData, payload) { console.log(`Webhook Event: ${webhookData.event}`); console.log(\u0026#39;Payload:\u0026#39;, payload); // Hier würde die eigentliche Webhook-Logik stehen switch (webhookData.event) { case \u0026#39;user.created\u0026#39;: handleUserCreated(payload); break; case \u0026#39;user.updated\u0026#39;: handleUserUpdated(payload); break; default: console.log(\u0026#39;Unbekanntes Event:\u0026#39;, webhookData.event); } } "},{"id":6,"href":"/de/docs/swt/spezifikation/","title":"Spezifikation","section":"SWT","content":" Spezifikation # Überblick # Secure Webhook Token (SWT) ist eine spezialisierte Implementierung von JSON Web Tokens (JWT), die für die sichere Autorisierung von Webhook-Anfragen entwickelt wurde. Die Spezifikation ist darauf ausgelegt, leichtgewichtig, flexibel und kompatibel mit Standard-JWT-Strukturen zu sein.\nJWT-Struktur # Ein SWT besteht aus den standardmäßigen JWT-Komponenten:\nHeader (Kopfzeile) Payload (Nutzdaten) Signature (Signatur) Header-Anforderungen # Der Header muss folgende Felder enthalten:\n{ \u0026#34;alg\u0026#34;: \u0026#34;HS256\u0026#34;, \u0026#34;typ\u0026#34;: \u0026#34;JWT\u0026#34; } alg: Signaturalgorithmus (typischerweise \u0026ldquo;HS256\u0026rdquo;) typ: Token-Typ (muss \u0026ldquo;JWT\u0026rdquo; sein) Payload-Anforderungen (Claims) # Pflicht-Claims # webhook: Benutzerdefinierter Claim mit event und optionalen data iss (Issuer): Aussteller des Tokens exp (Expiration): Ablaufzeit des Tokens nbf (Not Before): Zeitstempel, ab wann das Token gültig ist iat (Issued At): Zeitstempel der Token-Erstellung jti (JWT ID): Eindeutige Token-Identifikation Beispiel Payload # { \u0026#34;webhook\u0026#34;: { \u0026#34;event\u0026#34;: \u0026#34;user.created\u0026#34;, \u0026#34;data\u0026#34;: { \u0026#34;userId\u0026#34;: \u0026#34;12345\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;user@example.com\u0026#34; } }, \u0026#34;iss\u0026#34;: \u0026#34;webhook-service.example.com\u0026#34;, \u0026#34;exp\u0026#34;: 1703952000, \u0026#34;nbf\u0026#34;: 1703948400, \u0026#34;iat\u0026#34;: 1703948400, \u0026#34;jti\u0026#34;: \u0026#34;unique-token-id-123\u0026#34; } Übertragungsmethoden # HEAD-Methode (Empfohlen) # Für JSON-Nutzdaten ≤ 6kB wird die HEAD-Methode empfohlen:\nHEAD /webhook-endpoint HTTP/1.1 Host: api.example.com Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9... Content-Type: application/json Content-Length: 245 POST-Methode # Für größere Nutzdaten oder Nicht-JSON-Inhalte:\nPOST /webhook-endpoint HTTP/1.1 Host: api.example.com Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9... Content-Type: application/json Content-Length: 8192 { \u0026#34;userId\u0026#34;: \u0026#34;12345\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;user@example.com\u0026#34;, \u0026#34;profile\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;Max Mustermann\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;...\u0026#34; } } Hash-Algorithmen # Die Spezifikation unterstützt folgende Hash-Algorithmen für die Payload-Validierung:\nSHA-2 Familie: sha256, sha384, sha512 SHA-3 Familie: sha3-256, sha3-384, sha3-512 Beispiel mit Payload-Hash # { \u0026#34;webhook\u0026#34;: { \u0026#34;event\u0026#34;: \u0026#34;user.updated\u0026#34;, \u0026#34;hash\u0026#34;: \u0026#34;sha256:a665a45920422f9d417e4867efdc4fb8a04a1f3fff1fa07e998e86f7f7a27ae3\u0026#34; }, \u0026#34;iss\u0026#34;: \u0026#34;webhook-service.example.com\u0026#34;, \u0026#34;exp\u0026#34;: 1703952000, \u0026#34;iat\u0026#34;: 1703948400, \u0026#34;jti\u0026#34;: \u0026#34;token-456\u0026#34; } "},{"id":7,"href":"/de/docs/swt/sicherheit/","title":"Sicherheitsrichtlinien","section":"SWT","content":" Sicherheitsrichtlinien # Transport-Sicherheit # HTTPS verwenden # Alle Webhook-Kommunikation muss über HTTPS erfolgen. HTTP-Verbindungen sind nicht zulässig.\nTLS-Anforderungen # Mindestanforderung: TLS 1.2+ Empfohlen: TLS 1.3 für optimale Sicherheit Token-Sicherheit # Replay-Schutz implementieren # // Beispiel: JTI-basierter Replay-Schutz const usedTokens = new Set(); function checkReplayProtection(jti) { if (usedTokens.has(jti)) { throw new Error(\u0026#39;Token bereits verwendet (Replay-Angriff)\u0026#39;); } usedTokens.add(jti); } Token-Ablauf validieren # function validateTokenTiming(decoded) { const now = Math.floor(Date.now() / 1000); if (decoded.exp \u0026lt;= now) { throw new Error(\u0026#39;Token ist abgelaufen\u0026#39;); } if (decoded.nbf \u0026gt; now) { throw new Error(\u0026#39;Token ist noch nicht gültig\u0026#39;); } } JSON Web Signatures (JWS) # Pflicht: Alle Tokens müssen signiert sein Empfohlene Algorithmen: HS256, RS256, ES256 JSON Web Encryption (JWE) # Optional: Für sensible Daten empfohlen Algorithmen: A256GCM, A256CBC-HS512 Validierungsanforderungen # HEAD-Anfragen # 1. JWT-Signatur validieren 2. Token-Ablauf prüfen 3. Issuer verifizieren 4. Replay-Schutz durchführen POST-Anfragen # 1. JWT-Signatur validieren 2. Token-Ablauf prüfen 3. Payload-Hash verifizieren 4. Content-Length validieren 5. Replay-Schutz durchführen Best Practices # Token-Lebensdauer # Kurze Gültigkeitsdauer: Maximal 5-15 Minuten Angemessene nbf-Zeit: 1-2 Minuten vor aktueller Zeit für Clock-Skew Replay-Schutz # JTI-Tracking: Bereits verwendete Token-IDs speichern TTL-basierte Bereinigung: Alte JTIs automatisch entfernen // Beispiel: TTL-basierte JTI-Bereinigung class TokenReplayProtection { constructor() { this.usedTokens = new Map(); } addToken(jti, expiration) { this.usedTokens.set(jti, expiration); this.cleanupExpiredTokens(); } cleanupExpiredTokens() { const now = Date.now() / 1000; for (const [jti, exp] of this.usedTokens.entries()) { if (exp \u0026lt; now) { this.usedTokens.delete(jti); } } } } Monitoring und Logging # Fehlgeschlagene Validierungen protokollieren Verdächtige Aktivitäten überwachen Token-Verwendungsstatistiken erfassen // Beispiel: Sicherheits-Logging function logSecurityEvent(event, details) { console.log(JSON.stringify({ timestamp: new Date().toISOString(), event: event, details: details, severity: event.includes(\u0026#39;failed\u0026#39;) ? \u0026#39;HIGH\u0026#39; : \u0026#39;INFO\u0026#39; })); } "},{"id":8,"href":"/de/docs/swt/fehlerbehandlung/","title":"Fehlerbehandlung","section":"SWT","content":" Fehlerbehandlung # Häufige Validierungsfehler # Fehler Ursache Lösung Token expired Token ist abgelaufen Neues Token anfordern Invalid signature Falscher Schlüssel oder manipuliertes Token Schlüssel überprüfen Hash mismatch Payload wurde verändert Originale Payload verwenden Missing claims Pflicht-Claims fehlen Token-Struktur korrigieren Token not yet valid nbf-Claim liegt in der Zukunft Clock-Synchronisation prüfen Replay attack detected JTI bereits verwendet Neues Token generieren Beispiel-Fehlerbehandlung # app.post(\u0026#39;/webhook\u0026#39;, (req, res) =\u0026gt; { try { const token = req.headers.authorization?.replace(\u0026#39;Bearer \u0026#39;, \u0026#39;\u0026#39;); const validatedToken = validateSWT(token, req.body, SECRET_KEY); // Webhook verarbeiten processWebhook(validatedToken.webhook, req.body); res.status(200).json({ status: \u0026#39;success\u0026#39; }); } catch (error) { console.error(\u0026#39;Webhook-Validierung fehlgeschlagen:\u0026#39;, error.message); // Spezifische Fehlerbehandlung if (error.message.includes(\u0026#39;expired\u0026#39;)) { return res.status(401).json({ error: \u0026#39;TOKEN_EXPIRED\u0026#39;, message: \u0026#39;Token ist abgelaufen\u0026#39; }); } if (error.message.includes(\u0026#39;signature\u0026#39;)) { return res.status(401).json({ error: \u0026#39;INVALID_SIGNATURE\u0026#39;, message: \u0026#39;Token-Signatur ungültig\u0026#39; }); } if (error.message.includes(\u0026#39;Hash\u0026#39;)) { return res.status(400).json({ error: \u0026#39;PAYLOAD_MISMATCH\u0026#39;, message: \u0026#39;Payload wurde verändert\u0026#39; }); } // Allgemeiner Fehler res.status(401).json({ error: \u0026#39;UNAUTHORIZED\u0026#39;, message: \u0026#39;Token-Validierung fehlgeschlagen\u0026#39; }); } }); Erweiterte Fehlerbehandlung # Fehlerklassen definieren # class SWTError extends Error { constructor(message, code, statusCode = 401) { super(message); this.name = \u0026#39;SWTError\u0026#39;; this.code = code; this.statusCode = statusCode; } } class TokenExpiredError extends SWTError { constructor() { super(\u0026#39;Token ist abgelaufen\u0026#39;, \u0026#39;TOKEN_EXPIRED\u0026#39;, 401); } } class InvalidSignatureError extends SWTError { constructor() { super(\u0026#39;Token-Signatur ungültig\u0026#39;, \u0026#39;INVALID_SIGNATURE\u0026#39;, 401); } } class PayloadMismatchError extends SWTError { constructor() { super(\u0026#39;Payload-Hash stimmt nicht überein\u0026#39;, \u0026#39;PAYLOAD_MISMATCH\u0026#39;, 400); } } class ReplayAttackError extends SWTError { constructor() { super(\u0026#39;Token bereits verwendet\u0026#39;, \u0026#39;REPLAY_ATTACK\u0026#39;, 401); } } Verbesserte Validierungsfunktion # function validateSWT(token, payload, secret) { try { const decoded = jwt.verify(token, secret); // Pflicht-Claims prüfen const requiredClaims = [\u0026#39;webhook\u0026#39;, \u0026#39;iss\u0026#39;, \u0026#39;exp\u0026#39;, \u0026#39;nbf\u0026#39;, \u0026#39;iat\u0026#39;, \u0026#39;jti\u0026#39;]; for (const claim of requiredClaims) { if (!decoded[claim]) { throw new SWTError(`Fehlender Pflicht-Claim: ${claim}`, \u0026#39;MISSING_CLAIM\u0026#39;, 400); } } // Zeitvalidierung const now = Math.floor(Date.now() / 1000); if (decoded.exp \u0026lt;= now) { throw new TokenExpiredError(); } if (decoded.nbf \u0026gt; now) { throw new SWTError(\u0026#39;Token noch nicht gültig\u0026#39;, \u0026#39;TOKEN_NOT_YET_VALID\u0026#39;, 401); } // Payload-Hash validieren if (payload \u0026amp;\u0026amp; decoded.webhook.hash) { const [algorithm, expectedHash] = decoded.webhook.hash.split(\u0026#39;:\u0026#39;); const actualHash = crypto.createHash(algorithm) .update(JSON.stringify(payload)) .digest(\u0026#39;hex\u0026#39;); if (actualHash !== expectedHash) { throw new PayloadMismatchError(); } } return decoded; } catch (error) { if (error instanceof SWTError) { throw error; } if (error.name === \u0026#39;TokenExpiredError\u0026#39;) { throw new TokenExpiredError(); } if (error.name === \u0026#39;JsonWebTokenError\u0026#39;) { throw new InvalidSignatureError(); } throw new SWTError(\u0026#39;Unbekannter Validierungsfehler\u0026#39;, \u0026#39;VALIDATION_ERROR\u0026#39;, 500); } } Logging und Monitoring # Strukturiertes Logging # const winston = require(\u0026#39;winston\u0026#39;); const logger = winston.createLogger({ level: \u0026#39;info\u0026#39;, format: winston.format.combine( winston.format.timestamp(), winston.format.errors({ stack: true }), winston.format.json() ), transports: [ new winston.transports.File({ filename: \u0026#39;webhook-errors.log\u0026#39;, level: \u0026#39;error\u0026#39; }), new winston.transports.File({ filename: \u0026#39;webhook-combined.log\u0026#39; }) ] }); function logWebhookEvent(event, details, level = \u0026#39;info\u0026#39;) { logger.log({ level: level, message: \u0026#39;Webhook Event\u0026#39;, event: event, details: details, timestamp: new Date().toISOString() }); } // Verwendung try { const validatedToken = validateSWT(token, req.body, SECRET_KEY); logWebhookEvent(\u0026#39;webhook_validated\u0026#39;, { event: validatedToken.webhook.event, jti: validatedToken.jti, issuer: validatedToken.iss }); } catch (error) { logWebhookEvent(\u0026#39;webhook_validation_failed\u0026#39;, { error: error.message, code: error.code, ip: req.ip, userAgent: req.get(\u0026#39;User-Agent\u0026#39;) }, \u0026#39;error\u0026#39;); } Metriken und Alerting # const prometheus = require(\u0026#39;prom-client\u0026#39;); // Metriken definieren const webhookValidationCounter = new prometheus.Counter({ name: \u0026#39;webhook_validation_total\u0026#39;, help: \u0026#39;Total number of webhook validations\u0026#39;, labelNames: [\u0026#39;status\u0026#39;, \u0026#39;error_type\u0026#39;] }); const webhookValidationDuration = new prometheus.Histogram({ name: \u0026#39;webhook_validation_duration_seconds\u0026#39;, help: \u0026#39;Duration of webhook validation\u0026#39;, buckets: [0.1, 0.5, 1, 2, 5] }); // Metriken verwenden app.post(\u0026#39;/webhook\u0026#39;, async (req, res) =\u0026gt; { const startTime = Date.now(); try { const validatedToken = validateSWT(token, req.body, SECRET_KEY); webhookValidationCounter.inc({ status: \u0026#39;success\u0026#39;, error_type: \u0026#39;none\u0026#39; }); processWebhook(validatedToken.webhook, req.body); res.status(200).json({ status: \u0026#39;success\u0026#39; }); } catch (error) { webhookValidationCounter.inc({ status: \u0026#39;error\u0026#39;, error_type: error.code || \u0026#39;unknown\u0026#39; }); res.status(error.statusCode || 500).json({ error: error.code || \u0026#39;UNKNOWN_ERROR\u0026#39;, message: error.message }); } finally { const duration = (Date.now() - startTime) / 1000; webhookValidationDuration.observe(duration); } }); Rate Limiting # const rateLimit = require(\u0026#39;express-rate-limit\u0026#39;); const webhookLimiter = rateLimit({ windowMs: 15 * 60 * 1000, // 15 Minuten max: 100, // Maximal 100 Requests pro IP message: { error: \u0026#39;RATE_LIMIT_EXCEEDED\u0026#39;, message: \u0026#39;Zu viele Webhook-Anfragen\u0026#39; }, standardHeaders: true, legacyHeaders: false, skip: (req) =\u0026gt; { // Authentifizierte Requests weniger limitieren const token = req.headers.authorization?.replace(\u0026#39;Bearer \u0026#39;, \u0026#39;\u0026#39;); try { jwt.verify(token, SECRET_KEY); return false; // Nicht skippen, aber weniger streng limitieren } catch { return false; } } }); app.use(\u0026#39;/webhook\u0026#39;, webhookLimiter); "},{"id":9,"href":"/de/docs/swt/implementations/","title":"Implementierungen","section":"SWT","content":" Implementierungen # Contribution wanted!\nWenn du eine Library für eine andere Sprache kennst oder eine erstellt hast, lass es mich wissen und ich trage sie hier ein.\nHier ist eine Liste mit Implementierungen in verschiedenen Programmiersprachen.\nGo # SecureWebhookToken (SWT) JS # ??? Python # ??? "}]