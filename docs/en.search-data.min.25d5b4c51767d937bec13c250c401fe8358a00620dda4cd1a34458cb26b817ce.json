[{"id":0,"href":"/docs/swt/implementations/examples/go/client-side-token-generation/","title":"Client-side Token Generation","section":"Go","content":" Client-side Token Generation # TBD!\n"},{"id":1,"href":"/docs/swt/implementations/examples/js/client-side-token-generation/","title":"Client-side Token Generation","section":"JS","content":" Client-side Token Generation # // For HEAD requests (small payloads) function sendWebhookHEAD(endpoint, webhookData, secret) { const token = createSWT(webhookData, null, secret); return fetch(endpoint, { method: \u0026#39;HEAD\u0026#39;, headers: { \u0026#39;Authorization\u0026#39;: `Bearer ${token}`, \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39; } }); } // For POST requests (larger payloads) function sendWebhookPOST(endpoint, webhookData, payload, secret) { const token = createSWT(webhookData, payload, secret); return fetch(endpoint, { method: \u0026#39;POST\u0026#39;, headers: { \u0026#39;Authorization\u0026#39;: `Bearer ${token}`, \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39; }, body: JSON.stringify(payload) }); } "},{"id":2,"href":"/docs/swt/implementations/examples/python/create-validate-secure-webhook-token/","title":"Create \u0026 Validate Secure Webhook Token","section":"Python","content":" Create \u0026amp; Validate Secure Webhook Token # import jwt import hashlib import json import time import uuid from datetime import datetime, timedelta def create_swt(webhook_data, payload=None, secret=None): now = int(time.time()) claims = { \u0026#39;webhook\u0026#39;: { \u0026#39;event\u0026#39;: webhook_data[\u0026#39;event\u0026#39;], \u0026#39;data\u0026#39;: webhook_data.get(\u0026#39;data\u0026#39;, {}) }, \u0026#39;iss\u0026#39;: \u0026#39;webhook-service.example.com\u0026#39;, \u0026#39;exp\u0026#39;: now + 300, # Valid for 5 minutes \u0026#39;nbf\u0026#39;: now, \u0026#39;iat\u0026#39;: now, \u0026#39;jti\u0026#39;: str(uuid.uuid4()) } # Add payload hash if present if payload: payload_str = json.dumps(payload, separators=(\u0026#39;,\u0026#39;, \u0026#39;:\u0026#39;), sort_keys=True) hash_obj = hashlib.sha256(payload_str.encode(\u0026#39;utf-8\u0026#39;)) claims[\u0026#39;webhook\u0026#39;][\u0026#39;hash\u0026#39;] = f\u0026#34;sha256:{hash_obj.hexdigest()}\u0026#34; return jwt.encode(claims, secret, algorithm=\u0026#39;HS256\u0026#39;) def validate_swt(token, payload=None, secret=None): try: decoded = jwt.decode(token, secret, algorithms=[\u0026#39;HS256\u0026#39;]) # Check required claims required_claims = [\u0026#39;webhook\u0026#39;, \u0026#39;iss\u0026#39;, \u0026#39;exp\u0026#39;, \u0026#39;nbf\u0026#39;, \u0026#39;iat\u0026#39;, \u0026#39;jti\u0026#39;] for claim in required_claims: if claim not in decoded: raise ValueError(f\u0026#39;Missing required claim: {claim}\u0026#39;) # Validate payload hash if present if payload and \u0026#39;hash\u0026#39; in decoded[\u0026#39;webhook\u0026#39;]: algorithm, expected_hash = decoded[\u0026#39;webhook\u0026#39;][\u0026#39;hash\u0026#39;].split(\u0026#39;:\u0026#39;) payload_str = json.dumps(payload, separators=(\u0026#39;,\u0026#39;, \u0026#39;:\u0026#39;), sort_keys=True) if algorithm == \u0026#39;sha256\u0026#39;: actual_hash = hashlib.sha256(payload_str.encode(\u0026#39;utf-8\u0026#39;)).hexdigest() else: raise ValueError(f\u0026#39;Unsupported hash algorithm: {algorithm}\u0026#39;) if actual_hash != expected_hash: raise ValueError(\u0026#39;Payload hash mismatch\u0026#39;) return decoded except jwt.InvalidTokenError as e: raise ValueError(f\u0026#39;SWT validation failed: {str(e)}\u0026#39;) "},{"id":3,"href":"/docs/swt/implementations/examples/js/replay-protection/","title":"Replay Protection with Redis","section":"JS","content":" Replay Protection with Redis # const redis = require(\u0026#39;redis\u0026#39;); const client = redis.createClient(); class RedisReplayProtection { constructor(redisClient) { this.redis = redisClient; } async checkAndAddToken(jti, expiration) { const exists = await this.redis.exists(`swt:${jti}`); if (exists) { throw new Error(\u0026#39;Token already used (replay attack)\u0026#39;); } const ttl = expiration - Math.floor(Date.now() / 1000); if (ttl \u0026gt; 0) { await this.redis.setex(`swt:${jti}`, ttl, \u0026#39;1\u0026#39;); } } } // Usage const replayProtection = new RedisReplayProtection(client); async function validateSWTWithReplayProtection(token, payload, secret) { const decoded = validateSWT(token, payload, secret); await replayProtection.checkAndAddToken(decoded.jti, decoded.exp); return decoded; } "},{"id":4,"href":"/docs/swt/implementations/examples/js/server-side-validation/","title":"Server-side Validation","section":"JS","content":" Server-side Validation (Node.js) # Complete SWT Validation # const jwt = require(\u0026#39;jsonwebtoken\u0026#39;); const crypto = require(\u0026#39;crypto\u0026#39;); function validateSWT(token, payload, secret) { try { // Decode and validate JWT const decoded = jwt.verify(token, secret); // Check required claims if (!decoded.webhook || !decoded.iss || !decoded.exp || !decoded.nbf || !decoded.iat || !decoded.jti) { throw new Error(\u0026#39;Missing required claims\u0026#39;); } // Time validation const now = Math.floor(Date.now() / 1000); if (decoded.exp \u0026lt;= now || decoded.nbf \u0026gt; now) { throw new Error(\u0026#39;Token expired or not yet valid\u0026#39;); } // Validate payload hash (if present) if (payload \u0026amp;\u0026amp; decoded.webhook.hash) { const [algorithm, expectedHash] = decoded.webhook.hash.split(\u0026#39;:\u0026#39;); const actualHash = crypto.createHash(algorithm) .update(JSON.stringify(payload)) .digest(\u0026#39;hex\u0026#39;); if (actualHash !== expectedHash) { throw new Error(\u0026#39;Payload hash mismatch\u0026#39;); } } return decoded; } catch (error) { throw new Error(`SWT validation failed: ${error.message}`); } } Token Creation # const jwt = require(\u0026#39;jsonwebtoken\u0026#39;); const crypto = require(\u0026#39;crypto\u0026#39;); function createSWT(webhookData, payload, secret) { const now = Math.floor(Date.now() / 1000); const claims = { webhook: { event: webhookData.event, data: webhookData.data }, iss: \u0026#39;webhook-service.example.com\u0026#39;, exp: now + 300, // Valid for 5 minutes nbf: now, iat: now, jti: crypto.randomUUID() }; // Add payload hash (if present) if (payload) { const hash = crypto.createHash(\u0026#39;sha256\u0026#39;) .update(JSON.stringify(payload)) .digest(\u0026#39;hex\u0026#39;); claims.webhook.hash = `sha256:${hash}`; } return jwt.sign(claims, secret, { algorithm: \u0026#39;HS256\u0026#39; }); } "},{"id":5,"href":"/docs/swt/implementations/examples/js/webhook-handler/","title":"Webhook Handler","section":"JS","content":" Webhook Handler (Express.js) # const express = require(\u0026#39;express\u0026#39;); const app = express(); app.use(express.json()); app.post(\u0026#39;/webhook\u0026#39;, (req, res) =\u0026gt; { try { const token = req.headers.authorization?.replace(\u0026#39;Bearer \u0026#39;, \u0026#39;\u0026#39;); if (!token) { return res.status(401).json({ error: \u0026#39;Authorization header missing\u0026#39; }); } const validatedToken = validateSWT(token, req.body, process.env.WEBHOOK_SECRET); // Process webhook processWebhook(validatedToken.webhook, req.body); res.status(200).json({ status: \u0026#39;success\u0026#39; }); } catch (error) { console.error(\u0026#39;Webhook validation failed:\u0026#39;, error.message); res.status(401).json({ error: \u0026#39;Unauthorized\u0026#39;, message: error.message }); } }); function processWebhook(webhookData, payload) { console.log(`Webhook Event: ${webhookData.event}`); console.log(\u0026#39;Payload:\u0026#39;, payload); // Actual webhook logic would go here switch (webhookData.event) { case \u0026#39;user.created\u0026#39;: handleUserCreated(payload); break; case \u0026#39;user.updated\u0026#39;: handleUserUpdated(payload); break; default: console.log(\u0026#39;Unknown event:\u0026#39;, webhookData.event); } } "},{"id":6,"href":"/docs/swt/specification/","title":"Specification","section":"SWT","content":" Specification # Overview # Secure Webhook Token (SWT) is a specialized implementation of JSON Web Tokens (JWT) designed for secure authorization of webhook requests. The specification is designed to be lightweight, flexible, and compatible with standard JWT structures.\nJWT Structure # An SWT consists of the standard JWT components:\nHeader Payload Signature Header Requirements # The header must contain the following fields:\n{ \u0026#34;alg\u0026#34;: \u0026#34;HS256\u0026#34;, \u0026#34;typ\u0026#34;: \u0026#34;JWT\u0026#34; } alg: Signature algorithm (typically \u0026ldquo;HS256\u0026rdquo;) typ: Token type (must be \u0026ldquo;JWT\u0026rdquo;) Payload Requirements (Claims) # Required Claims # webhook: Custom claim with event and optional data iss (Issuer): Token issuer exp (Expiration): Token expiration time nbf (Not Before): Timestamp from when the token is valid iat (Issued At): Token creation timestamp jti (JWT ID): Unique token identification Example Payload # { \u0026#34;webhook\u0026#34;: { \u0026#34;event\u0026#34;: \u0026#34;user.created\u0026#34;, \u0026#34;data\u0026#34;: { \u0026#34;userId\u0026#34;: \u0026#34;12345\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;user@example.com\u0026#34; } }, \u0026#34;iss\u0026#34;: \u0026#34;webhook-service.example.com\u0026#34;, \u0026#34;exp\u0026#34;: 1703952000, \u0026#34;nbf\u0026#34;: 1703948400, \u0026#34;iat\u0026#34;: 1703948400, \u0026#34;jti\u0026#34;: \u0026#34;unique-token-id-123\u0026#34; } Transmission Methods # HEAD Method (Recommended) # For JSON payloads â‰¤ 6kB, the HEAD method is recommended:\nHEAD /webhook-endpoint HTTP/1.1 Host: api.example.com Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9... Content-Type: application/json Content-Length: 245 POST Method # For larger payloads or non-JSON content:\nPOST /webhook-endpoint HTTP/1.1 Host: api.example.com Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9... Content-Type: application/json Content-Length: 8192 { \u0026#34;userId\u0026#34;: \u0026#34;12345\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;user@example.com\u0026#34;, \u0026#34;profile\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;John Doe\u0026#34;, \u0026#34;address\u0026#34;: \u0026#34;...\u0026#34; } } Hash Algorithms # The specification supports the following hash algorithms for payload validation:\nSHA-2 family: sha256, sha384, sha512 SHA-3 family: sha3-256, sha3-384, sha3-512 Example with Payload Hash # { \u0026#34;webhook\u0026#34;: { \u0026#34;event\u0026#34;: \u0026#34;user.updated\u0026#34;, \u0026#34;hash\u0026#34;: \u0026#34;sha256:a665a45920422f9d417e4867efdc4fb8a04a1f3fff1fa07e998e86f7f7a27ae3\u0026#34; }, \u0026#34;iss\u0026#34;: \u0026#34;webhook-service.example.com\u0026#34;, \u0026#34;exp\u0026#34;: 1703952000, \u0026#34;iat\u0026#34;: 1703948400, \u0026#34;jti\u0026#34;: \u0026#34;token-456\u0026#34; } "},{"id":7,"href":"/docs/swt/security/","title":"Security Guidelines","section":"SWT","content":" Security Guidelines # Transport Security # Use HTTPS # All webhook communication must occur over HTTPS. HTTP connections are not permitted.\nTLS Requirements # Minimum requirement: TLS 1.2+ Recommended: TLS 1.3 for optimal security Token Security # Implement Replay Protection # // Example: JTI-based replay protection const usedTokens = new Set(); function checkReplayProtection(jti) { if (usedTokens.has(jti)) { throw new Error(\u0026#39;Token already used (replay attack)\u0026#39;); } usedTokens.add(jti); } Validate Token Timing # function validateTokenTiming(decoded) { const now = Math.floor(Date.now() / 1000); if (decoded.exp \u0026lt;= now) { throw new Error(\u0026#39;Token has expired\u0026#39;); } if (decoded.nbf \u0026gt; now) { throw new Error(\u0026#39;Token is not yet valid\u0026#39;); } } JSON Web Signatures (JWS) # Required: All tokens must be signed Recommended algorithms: HS256, RS256, ES256 JSON Web Encryption (JWE) # Optional: Recommended for sensitive data Algorithms: A256GCM, A256CBC-HS512 Validation Requirements # HEAD Requests # 1. Validate JWT signature 2. Check token expiration 3. Verify issuer 4. Perform replay protection POST Requests # 1. Validate JWT signature 2. Check token expiration 3. Verify payload hash 4. Validate Content-Length 5. Perform replay protection Best Practices # Token Lifetime # Short validity period: Maximum 5-15 minutes Appropriate nbf time: 1-2 minutes before current time for clock skew Replay Protection # JTI tracking: Store already used token IDs TTL-based cleanup: Automatically remove old JTIs // Example: TTL-based JTI cleanup class TokenReplayProtection { constructor() { this.usedTokens = new Map(); } addToken(jti, expiration) { this.usedTokens.set(jti, expiration); this.cleanupExpiredTokens(); } cleanupExpiredTokens() { const now = Date.now() / 1000; for (const [jti, exp] of this.usedTokens.entries()) { if (exp \u0026lt; now) { this.usedTokens.delete(jti); } } } } Monitoring and Logging # Log failed validations Monitor suspicious activities Collect token usage statistics // Example: Security logging function logSecurityEvent(event, details) { console.log(JSON.stringify({ timestamp: new Date().toISOString(), event: event, details: details, severity: event.includes(\u0026#39;failed\u0026#39;) ? \u0026#39;HIGH\u0026#39; : \u0026#39;INFO\u0026#39; })); } "},{"id":8,"href":"/docs/swt/error-handling/","title":"Error Handling","section":"SWT","content":" Error Handling # Common Validation Errors # Error Cause Solution Token expired Token has expired Request new token Invalid signature Wrong key or manipulated token Verify key Hash mismatch Payload was modified Use original payload Missing claims Required claims missing Correct token structure Token not yet valid nbf-claim is in the future Check clock synchronization Replay attack detected JTI already used Generate new token Example Error Handling # app.post(\u0026#39;/webhook\u0026#39;, (req, res) =\u0026gt; { try { const token = req.headers.authorization?.replace(\u0026#39;Bearer \u0026#39;, \u0026#39;\u0026#39;); const validatedToken = validateSWT(token, req.body, SECRET_KEY); // Process webhook processWebhook(validatedToken.webhook, req.body); res.status(200).json({ status: \u0026#39;success\u0026#39; }); } catch (error) { console.error(\u0026#39;Webhook validation failed:\u0026#39;, error.message); // Specific error handling if (error.message.includes(\u0026#39;expired\u0026#39;)) { return res.status(401).json({ error: \u0026#39;TOKEN_EXPIRED\u0026#39;, message: \u0026#39;Token has expired\u0026#39; }); } if (error.message.includes(\u0026#39;signature\u0026#39;)) { return res.status(401).json({ error: \u0026#39;INVALID_SIGNATURE\u0026#39;, message: \u0026#39;Invalid token signature\u0026#39; }); } if (error.message.includes(\u0026#39;Hash\u0026#39;)) { return res.status(400).json({ error: \u0026#39;PAYLOAD_MISMATCH\u0026#39;, message: \u0026#39;Payload was modified\u0026#39; }); } // General error res.status(401).json({ error: \u0026#39;UNAUTHORIZED\u0026#39;, message: \u0026#39;Token validation failed\u0026#39; }); } }); Advanced Error Handling # Define Error Classes # class SWTError extends Error { constructor(message, code, statusCode = 401) { super(message); this.name = \u0026#39;SWTError\u0026#39;; this.code = code; this.statusCode = statusCode; } } class TokenExpiredError extends SWTError { constructor() { super(\u0026#39;Token has expired\u0026#39;, \u0026#39;TOKEN_EXPIRED\u0026#39;, 401); } } class InvalidSignatureError extends SWTError { constructor() { super(\u0026#39;Invalid token signature\u0026#39;, \u0026#39;INVALID_SIGNATURE\u0026#39;, 401); } } class PayloadMismatchError extends SWTError { constructor() { super(\u0026#39;Payload hash mismatch\u0026#39;, \u0026#39;PAYLOAD_MISMATCH\u0026#39;, 400); } } class ReplayAttackError extends SWTError { constructor() { super(\u0026#39;Token already used\u0026#39;, \u0026#39;REPLAY_ATTACK\u0026#39;, 401); } } Improved Validation Function # function validateSWT(token, payload, secret) { try { const decoded = jwt.verify(token, secret); // Check required claims const requiredClaims = [\u0026#39;webhook\u0026#39;, \u0026#39;iss\u0026#39;, \u0026#39;exp\u0026#39;, \u0026#39;nbf\u0026#39;, \u0026#39;iat\u0026#39;, \u0026#39;jti\u0026#39;]; for (const claim of requiredClaims) { if (!decoded[claim]) { throw new SWTError(`Missing required claim: ${claim}`, \u0026#39;MISSING_CLAIM\u0026#39;, 400); } } // Time validation const now = Math.floor(Date.now() / 1000); if (decoded.exp \u0026lt;= now) { throw new TokenExpiredError(); } if (decoded.nbf \u0026gt; now) { throw new SWTError(\u0026#39;Token not yet valid\u0026#39;, \u0026#39;TOKEN_NOT_YET_VALID\u0026#39;, 401); } // Validate payload hash if (payload \u0026amp;\u0026amp; decoded.webhook.hash) { const [algorithm, expectedHash] = decoded.webhook.hash.split(\u0026#39;:\u0026#39;); const actualHash = crypto.createHash(algorithm) .update(JSON.stringify(payload)) .digest(\u0026#39;hex\u0026#39;); if (actualHash !== expectedHash) { throw new PayloadMismatchError(); } } return decoded; } catch (error) { if (error instanceof SWTError) { throw error; } if (error.name === \u0026#39;TokenExpiredError\u0026#39;) { throw new TokenExpiredError(); } if (error.name === \u0026#39;JsonWebTokenError\u0026#39;) { throw new InvalidSignatureError(); } throw new SWTError(\u0026#39;Unknown validation error\u0026#39;, \u0026#39;VALIDATION_ERROR\u0026#39;, 500); } } Logging and Monitoring # Structured Logging # const winston = require(\u0026#39;winston\u0026#39;); const logger = winston.createLogger({ level: \u0026#39;info\u0026#39;, format: winston.format.combine( winston.format.timestamp(), winston.format.errors({ stack: true }), winston.format.json() ), transports: [ new winston.transports.File({ filename: \u0026#39;webhook-errors.log\u0026#39;, level: \u0026#39;error\u0026#39; }), new winston.transports.File({ filename: \u0026#39;webhook-combined.log\u0026#39; }) ] }); function logWebhookEvent(event, details, level = \u0026#39;info\u0026#39;) { logger.log({ level: level, message: \u0026#39;Webhook Event\u0026#39;, event: event, details: details, timestamp: new Date().toISOString() }); } // Usage try { const validatedToken = validateSWT(token, req.body, SECRET_KEY); logWebhookEvent(\u0026#39;webhook_validated\u0026#39;, { event: validatedToken.webhook.event, jti: validatedToken.jti, issuer: validatedToken.iss }); } catch (error) { logWebhookEvent(\u0026#39;webhook_validation_failed\u0026#39;, { error: error.message, code: error.code, ip: req.ip, userAgent: req.get(\u0026#39;User-Agent\u0026#39;) }, \u0026#39;error\u0026#39;); } Metrics and Alerting # const prometheus = require(\u0026#39;prom-client\u0026#39;); // Define metrics const webhookValidationCounter = new prometheus.Counter({ name: \u0026#39;webhook_validation_total\u0026#39;, help: \u0026#39;Total number of webhook validations\u0026#39;, labelNames: [\u0026#39;status\u0026#39;, \u0026#39;error_type\u0026#39;] }); const webhookValidationDuration = new prometheus.Histogram({ name: \u0026#39;webhook_validation_duration_seconds\u0026#39;, help: \u0026#39;Duration of webhook validation\u0026#39;, buckets: [0.1, 0.5, 1, 2, 5] }); // Use metrics app.post(\u0026#39;/webhook\u0026#39;, async (req, res) =\u0026gt; { const startTime = Date.now(); try { const validatedToken = validateSWT(token, req.body, SECRET_KEY); webhookValidationCounter.inc({ status: \u0026#39;success\u0026#39;, error_type: \u0026#39;none\u0026#39; }); processWebhook(validatedToken.webhook, req.body); res.status(200).json({ status: \u0026#39;success\u0026#39; }); } catch (error) { webhookValidationCounter.inc({ status: \u0026#39;error\u0026#39;, error_type: error.code || \u0026#39;unknown\u0026#39; }); res.status(error.statusCode || 500).json({ error: error.code || \u0026#39;UNKNOWN_ERROR\u0026#39;, message: error.message }); } finally { const duration = (Date.now() - startTime) / 1000; webhookValidationDuration.observe(duration); } }); Rate Limiting # const rateLimit = require(\u0026#39;express-rate-limit\u0026#39;); const webhookLimiter = rateLimit({ windowMs: 15 * 60 * 1000, // 15 minutes max: 100, // Maximum 100 requests per IP message: { error: \u0026#39;RATE_LIMIT_EXCEEDED\u0026#39;, message: \u0026#39;Too many webhook requests\u0026#39; }, standardHeaders: true, legacyHeaders: false, skip: (req) =\u0026gt; { // Limit authenticated requests less strictly const token = req.headers.authorization?.replace(\u0026#39;Bearer \u0026#39;, \u0026#39;\u0026#39;); try { jwt.verify(token, SECRET_KEY); return false; // Don\u0026#39;t skip, but limit less strictly } catch { return false; } } }); app.use(\u0026#39;/webhook\u0026#39;, webhookLimiter); "},{"id":9,"href":"/docs/swt/implementations/","title":"Implementations","section":"SWT","content":" Implementations # Contribution wanted!\nIf you know a library for another language or have created one, let me know and I\u0026rsquo;ll add it here.\nHere is a list of implementations in various programming languages.\nGo # SecureWebhookToken (SWT) JS # ??? Python # ??? "}]